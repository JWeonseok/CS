# Algorithm

## Sorting

정렬 알고리즘(`Sorting Algorithm`)은 크게 비교 여부에 따라 Comparison 방식과 Non-Comparison 방식 두 가지로 나뉘어 진다.

### Comparisons Sorting Algorithm

#### Selection Sort

선택 정렬(`Selection Sort`)은 n개의 원소를 가지는 배열에서, **현재 위치에서부터 맨 끝의 원소까지에서 최소값을 찾은 뒤, 현재 원소와 교환(`swap`)한다.** 교환 자체는 한 원소에 한 번 이루어지지만 비교는 n번 이루어진다.

- **Space Complexity** : O(1)
- **Time Complexity** : O($$n^2$$)



#### Insertion Sort

삽입 정렬(`Insertion Sort`)는 길이가 n인 배열에서, 현재 원소를 **맨 앞에서부터 현재 원소 이전까지배열에 삽입할 위치에 끼워 넣는다.** 위와 같은 방식이기 때문에 현재 원소 이전의 배열은 정렬이 되어있는 상태이다.

- **Space Complexity** : O(1)
- **Time Complexity** : O($$n^2$$)



#### Bubble Sort

버블 정렬(`Bubble Sort`)는 n개의 원소를 정렬할 때, 인접한 두 개의 원소를 비교하여 바꾸는 방식으로 진행한다. 한 번의 스캔으로 가장 큰 원소가 맨 끝으로 정렬된다.

- **Space Complexity** : O(1)
- **Time Complexity** : O($$n^2$$)



#### Merge Sort

합병 정렬(`Merge Sort`)를 이해하기 위해서 우선 **분할 정복**의 개념을 알아야 한다.

분할 정복(`Divide and Conquer`)는 **문제를 분할하여 작은 단위로 나누고, 작은 문제를 해결하고 결합하는 것을 의미한다.** 따라서 합병 정렬에서 분할 정복은 배열의 크기를 작게 나누어 정렬하는 알고리즘이다.

합병 정렬은 배열을 나누다가 더 이상 나누어지지 않을 때(원소의 개수가 하나일 때)가 되면 원소 하나를 반환한다. 그리고 이러한 원소가 결합(`combine`)될 때 비교하여 정렬하는 과정이다.

위에서 말했듯이 **나누는 과정이 반복이 일어나는, 즉 재귀적인 과정이 일어난다.**

- **Space Complexity** : O(n)
- **Time Complexity** : O(n log n)



#### Quick Sort

퀵 정렬(`Quick Sort`)은 **평균적**으로 가장 빠른 정렬방법이다. 하지만 Worst case에서는 O($$n^2$$)의 시간 복잡도를 가진다.

퀵 정렬의 알고리즘에서도 분할 정복의 개념이 사용된다. 크기가 n인 배열을 오름차순으로 정렬한다고 하자. 이 때 퀵 정렬은 기준이 되는 피벗(`pivot`)에서 피벗의 좌측은 피벗보다 작은 수들을, 우측은 큰 수들을 위치시킨다(`partition`). 그리고 다시 피벗을 제외한 좌측과 우측에 대해서 피벗을 두고 위의 과정을 반복하는 분할 과정이 재귀적으로 진행된다. 

이러한 퀵 정렬에서 **피벗이 제일 큰 수이거나 작은 수 일때 Worst case가 된다.** Partition이 한 쪽으로만 치우치기 때문에, 분할 과정이 n번 이루어지므로 시간 복잡도가 O($$n^2$$)가 된다.

역으로 피벗의 좌측과 우측이 반반으로 나뉘는 경우가 Best case가 된다. **따라서 어떤 원소를 피벗으로 정하는지에 따라 성능이 결정된다.** 임의의 원소를 피벗으로 설정하는 것으로 최악의 입력에 대한 성능 악화를 막을 수 있게 된다.

이제 퀵 정렬의 중요한 과정인 분할(`partition`)을 어떻게 할 것인지가 남아있다. 

예를 들어 피벗을 1번 원소라 하자. 그리고 **2번 원소와 n번 원소를 가리키는 포인터(`pointer`) low와 high**가 있다. 2번 원소가 피벗보다 작을 경우 low가 가리키는 원소의 번호를 증가시킨다. 즉, 3번 원소를 가리킨다. 

마찬가지로 n번 원소가 피벗보다 클 경우 high가 가리키는 원소의 번호를 감소시켜 n-1번 원소를 가리키게 한다.

이 때 low가 가리키는 원소가 피벗보다 크면 low의 진행을 정지하고, high가 가리키는 원소가 피벗보다 작으면 high의 진행을 정지한다. 그리고 **low와 high가 둘 다 정지하면 두 원소를 교환한다.**

위의 과정이 진행되면서 low가 가리키는 번호가 high보다 클 경우, 피벗과 high가 가리키는 원소를 교환함으로 partition 과정이 완료된다.

- **Space Complexity** : O(log n)
- **Time Complexity** : O(n log n)



### Non-Comparisons Sorting Algorithm

#### Radix Sort

기수 정렬(`Radix Sort`)의 경우 비교 정렬 시간 복잡도의 하한선인 log(n log n) 보다 좋을 수 있다. 하지만 이 정렬 알고리즘을 적용할 수 있는 **데이터가 제한적**이라는 단점이 있다. 기수 정렬은 **동일한 길이를 가지는 숫자나 단순 문자(알파벳 등) 같은 데이터**에 대해서만 적용이 가능하다.

기수(`radix`)는 데이터를 구성하는 기본 요소를 의미하고 이 기수를 기준으로 정렬이 진행된다. 하나의 기수마다 하나의 버켓(`bucket`)을 생성하여 원소들을 분류하고 정렬한다.

기수 정렬은 덜 중요한 수부터 정렬하는 LSD(`Least Significant Digit`)과 중요한 수부터 정렬하는 MSD(`Most Significant Digit`)로 나뉜다. 예를 들어 세 자리 수를 정렬할 때, LSD는 먼저 일의 자리를 기준으로, MSD는 백의 자리를 기준으로 먼저 정렬한다. 두 방식의 시간 복잡도는 동일하다.

- **Space Complexity** : O(n)
- **Time Complexity** : O(n)