# DataStructure

## Stack & Queue

- **Stack**

  **가장 최근에 들어온 데이터가 가장 먼저 나가는 후입선출**(`Last-In First-Out: LIFO`)의 특징을 가지는 선형 자료 구조.
  
  삽입(`push`)과 삭제(`pop`)이 일어나는 스택의 상단을 `top`이라 하고, 제일 하단을 `botton`이라고 한다.

- **Queue**

  **먼저 들어온 데이터가 먼저 나가는 선입선출**(`First-In First-Out: FIFO`)의 특징을 가지는 선형 자료 구조.
  
  삽입은 큐의 후단(`rear`)에서, 삭제는 전단(`front`)에서 일어난다.

  

  **추가 - Deque**
  
  덱은 `double - ended queue`의 줄임말로 **큐의 전단(`front`)과 후단(`rear`)에서 모두 삽입과 삭제가 가능한 큐**이다. 즉, 큐의 전후단 양방향으로 삽입과 삭제가 자유롭게 이루어지는 특징을 가진다.



## Array & Linked List

- **Array**

  배열(`Array`)는 데이터가 **논리적 순서에 따라 순차적으로 저장되며 물리적 저장 순서가 일치**한다는 특징을 가진다. 따라서 인덱스(`index`)에 따라서  원하는 데이터를 빠르게 탐색(`search`)가 가능하다는 장점을 가진다.
  
  반면에 배열에 삽입과 삭제의 과정에서 해당 인덱스 다음의 모든 원소들의 이동(`shift`)가 일어나야 하는 단점이 존재한다.

- **Linked List**

  연결 리스트(`Linked List`)는 위의 배열의 단점이 해결된 자료구조이다. 데이터마다 인덱스를 가지는 배열과는 달리 연결 리스트는 다음 순서의 원소에 대한 정보를 알고 있다. 따라서 삽입과 삭제의 과정에서 이 정보들을 이용하여 용이하게 수정이 가능하다.
  
  하지만 인덱스를 가지지 않기 때문에 필요한 원소를 얻어 내기 위해서는 앞에서 부터 차례로 탐색해야 하는 단점을 가진다. 

  

  **추가 - ArrayList**
  
  `ArrayList`는 말 그대로 배열의 특성을 가지는 `List`로 배열은 크기가 정적으로 고정이 되지만 ArrayList 는 크기가 동적인 특징을 가진다.



## Tree

트리는 위의 스택, 큐, 리스트와 같은 선형 자료 구조와는 다른 **계층적인 구조**를 가지는 자료 구조이다. 

- 트리 용어

  - 노드(`Node`) : 트리의 구성 요소
  - 간선(`Edge`) : 노드들 사이를 연결하는 선
  - 루트(`root`) : 부모가 없는 최상위 노드
  - 단말노드(`terminal node`) : 자식이 없는 노드
  - 비단말노드(`nonterminal node`) : 적어도 하나의 자식을 가지는 노드
  - 레벨(`level`) : 트리의 각층의 번호
  - 높이(`height`) : 트리의 최대 레벨

  #### Binary Tree

  이진 트리(`Binary Tree`)는 모든 노드가 2개의 서브 트리를 가지는 트리를 말한다. 좀 더 쉽게 말해서 루트 노드가 두 개의 서브 트리를 가진다. 그럼 각각의 서브 트리의 루트 노드를 중심으로 두 개의 서브 트리를 가지는 재귀적인 개념으로 내려가게 된다.

  서브 트리는 공집합일 수 있다. 따라서 위와 같이 내려가서 리프 노드(`leaf node`)에 도달했을 때도 정의를 만족한다. 같은 개념으로 하나의 노드 또한 이진 트리 개념에 부합한다.

  - **Full Binary Tree**

    정 이진 트리(`Full Binary Tree`)는 모든 노드가 0개 또는 2개의 자식을 갖는 트리를 말한다. 즉, 하나의 자식을 가지는 노드가 없는 이진 트리이다.

  - **Complete Binary Tree**

    완전 이진 트리(`Complete Binary Tree`)는 리프 노드를 제외한 모든 노드들이 2개의 자식 노드를 가져야 하며 마지막 리프 노드의 형제 노드가 없을 경우 왼쪽에 위치해야 한다.

  - **Perfect Binary Tree**

    포화 이진 트리(`Perfect Binary Tree`)는 모든 레벨의 노드들이 꽉 차 있는 트리를 의미한다. 높이가 n인 포화 이진 트리는 2<sup>n+1</sup> 개의 노드를 가진다.

  

  **추가 - 이진 트리 순회**

  이진 트리의 노드들을 방문하는 순회는 **전위 순회, 중위 순회, 후위 순회**로 3가지 방법이 있다.

  전위 순회 : 루트 - 왼쪽 자식 노드 - 오른쪽 자식 노드

  중위 순회 : 왼쪽 자식 노드 - 루트 - 오른쪽 자식 노드

  후위 순회 : 왼쪽 자식 노드 - 오른쪽 자식 노드 - 루트 노드

  각 순회는 위와 같은 순서로 노드를 방문한다.

  

  #### Binary Search Tree

  위의 이진 트리의 구조와 특징을 이용하여 효율적인 탐색을 위한 자료구조가 이진 탐색 트리(`Binary Search Tree`)이다.  다만 이를 위하여 몇 가지 규칙 정의가 필요하다

  1. 모든 원소의 키는 유일한 키를 가진다.
  2. 왼쪽 서브 트리 키들은 루트 키보다 작다.
  3. 오른쪽 서브 트리의 키들은 루트의 키보다 크다.
  4. 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.

  

  이진 트리의 구조로 인해 노드와 인덱스의 관계에서 인덱스 i 노드의 부모 노드 인덱스는 i/2, 왼쪽 자식 노드 인덱스는 2i, 오른쪽 자식 노드 인덱스는 2i + 1을 가진다. 또한 이진 탐색 트리를 중위 순회할 경우 데이터가 오름차순으로 정렬된다.

  이진 탐색 트리에서의 탐색 연산은 노드 n개, 높이가 h인 트리에서 O(log<sub>2</sub>n) = O(h)의 시간 복잡도를 가진다. 다만 최악의 경우 한쪽으로 치우친 편향 트리(`Skewed Tree`)일 때 높이 h가 노드 개수와 동일하므로 시간복잡도가 O(n)이 된다.

  

  #### Heap Tree

  힙(`Heap`)은 위의 이진 탐색 트리처럼 몇 가지 규칙들을 가지는 완전 이진 트리이다. 힙은 두 종류가 있으며 규칙은 다음과 같다.

  최대 힙(`max heap`) : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리

  최소 힙(`min heap`) : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

  위와 같은 특징을 가지므로 최대 힙에서 최대값을 얻는데 시간 복잡도는 O(1), 최소 힙에서 최소값을 얻는데 O(1)를 가진다. 다만 최소, 최대값을 얻어낸 후 힙의 구조를 유지하기 위해 제거된 루트 노드를 대체하는 연산이 필요하다. 이 때 힙은 이진 트리의 구조를 가지므로 연산의 시간 복잡도는 O(log n)이다. 추가적으로 이러한 힙을 이용하여 정렬하는 힙 정렬(`heap sort`)는 n개를 정렬할 때 O(nlog n)의 시간 복잡도를 가진다.
  
  
  
  #### Red-Black Tree
  
  위에서 언급한 내용 중에서, 이진 탐색 트리가 편향 트리일 경우 시간 복잡도가 O(h)로 늘어난다. 이를 방지하기 위해서 이진 탐색 트리의 구조를 가지면서 몇 가지 조건들을 충족시키는 트리를 레드블랙 트리(`Red-Black Tree`)이다. 그 조건들은 다음과 같다.
  
  1. 트리의 모든 노드들은 레드 또는 블랙의 색을 가진다.
  2. 트리의 루트 노드의 색은 블랙이다. (`Root Property`)
  3. 트리의 리프 노드의 색은 블랙이다. (`External Property`)
  4. 레드 노드의 자식 노드는 블랙이다. 즉, 레드 노드들은 연속할 수 없다. (`Internal Property`)
  5. 모든 리프 노드에서 루트 노드까지의 경로에서 블랙 노드의 개수는 같다. (`Depth Property`)
  
  이러한 레드블랙 트리에서 삽입과 삭제가 일어날 때, 위의 조건들을 충족하기 위한 **트리의 변형**이 필요하다. 바로 `Restructuring`과 `Recoloring`이다.
  
  우선 삽입되는 노드는 항상 빨간 노드이다. 이 때, 부모의 형제 노드(삼촌 노드)의 색을 보고 블랙일 경우 Restructuring, 레드일 경우 Recoloring을 적용한다. 다음의 예시를 보자.
  
  ![](https://media.vlpt.us/images/agugu95/post/76dc5c8c-c1cd-4c34-9429-8ab51152348e/image.png)
  
  ![](https://media.vlpt.us/images/agugu95/post/45db91d6-5429-49f7-a789-8adc3a71be7d/image.png)
  
  위의 사진에서 노드가 삽입될 때(`z`), 빨간 노드의 중복이 일어난다. 이때 삼촌 노드(`w`)가 블랙이므로 Restructuring을 해야한다. Restructuring은 다음과 같다.
  
  1. 삽입 노드(`z`)와 부모 노드(`v`), 부모의 부모 노드를 오름차순 정렬한다.
  2. 중간값의 노드를 부모로 변경하고, 나머지 노드를 자식으로 만든다.
  3. 중간값의 노드의 색은 블랙, 자식 노드들은 레드로 변경한다.
  
  ![](https://media.vlpt.us/images/agugu95/post/eeaee48d-d815-40ec-9797-f7ab9e8adddd/image.png)
  
  ![](https://media.vlpt.us/images/agugu95/post/9f533d60-baf2-4dca-88a5-815b3661ab75/image.png)
  
  위와 같이 삼촌 노드(`w`)가 레드인 경우, Recoloring이 적용된다. Recoloring은 다음과 같다.
  
  1. 삽입 노드(`z`)의 부모 노드(`v`)와 삼촌 노드(`w`)를 블랙으로, 부모의 부모노드를 레드로 변경한다.
  2. 부모의 부모 노드가 루트 노드가 아닌 경우, 다시 레드 노드의 연속이 발생할 수 있다.
  
  2번에서 언급했듯이, Recoloring의 경우 Restructuring과는 다르게 레드 노드의 연속이 재발생되어 위로 propagation이 발생할 수 있다. 그렇다면 또 다시 Restructuring과 Recoloring을 적용하며 레드블랙 트리의 구조를 유지해야 한다.
  
  
  
  레드블랙 트리의 삽입과 삭제에서 시간 복잡도를 생각해보자.
  
  우선 노드의 위치를 알기위해서 O(logn)의 시간이 걸린다. 그리고 Restructuring과 Recoloring의 시간 복잡도가 O(1)이다. Recoloring의 propagation이 최악의 경우 루트 노드까지 발생했을 경우, O(logn)이 걸리게 된다.
  
  **즉, 결론적으로 레드블랙 트리의 삽입, 삭제의 시간 복잡도는 O(logn)이 걸리게 된다.**



## Graph

그래프(`Graph`)는 **연결되어 있는 객체 간의 관계**를 표현하는 자료구조이다. 추가적으로 트리는 사이클이 없는 그래프이다.
